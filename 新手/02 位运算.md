获取一个十进制数的32位二进制数

& 与运算

![](images\位运算01.jpg)





2进制转10进制

左移算法

![](images\位运算02.jpg)

无符号32位表示范围：0 ~ 2^32-1

有符号32位表示范围：-2^31 ~ 2^31-1



相反数算法:n 的相反数 = ~n+1

![](images\位运算04.jpg)


最小数和0取反是自己

0取反使用公式计算后会溢出，溢出的数不算，那么就等于原来


### 反码

计算有符号的位运算的负数时：

注意：计算负数时，取反之后需要+1

![](images\位运算03.jpg)

为什么负数的二进制存放如此奇葩，又要取反，又要+1?

因为和位运算的计算效率性能有关，为了提升正负数的计算性能，如果没有这种负数存储设计，则加减乘除都要在底层写两套逻辑，以后每次计算都要首先判断是否正负数



### 补码





### 